name: Reusable Docker Build and Test

on:
  workflow_call:
    inputs:
      platform:
        description: 'Target platform (e.g., linux/amd64, linux/arm64)'
        required: true
        type: string
      target:
        description: 'Dockerfile target to build'
        required: false
        type: string
        default: 'test'
      tags:
        description: 'Docker image tag(s), comma-separated (first tag is used for running tests)'
        required: true
        type: string
      base-image:
        description: 'Base image name (build arg BASE_IMG)'
        required: false
        type: string
        default: 'ubuntu'
      base-image-tag:
        description: 'Base image tag (build arg BASE_IMG_TAG)'
        required: false
        type: string
        default: 'jammy-20250415.1'
      runner:
        description: 'GitHub runner to use'
        required: false
        type: string
        default: 'ubuntu-latest'
      use-qemu:
        description: 'Enable QEMU emulation (for cross-arch builds/runs)'
        required: false
        type: boolean
        default: false
      download-llama-tokenizer:
        description: 'Set Docker build arg DOWNLOAD_LLAMA_TOKENIZER'
        required: false
        type: boolean
        default: true
      test-selection:
        description: 'Test selection strategy (full or random)'
        required: false
        type: string
        default: 'full'
      random-count:
        description: 'Number of tests to run when test-selection=random'
        required: false
        type: string
        default: '100'
      pytest-markers:
        description: 'Pytest markers expression'
        required: false
        type: string
        default: 'not integration'
      coverage:
        description: 'Collect coverage.xml and upload it'
        required: false
        type: boolean
        default: true
    secrets:
      HF_ACCESS_TOKEN:
        required: false

jobs:
  build-and-test:
    runs-on: ${{ inputs.runner }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up QEMU
        if: ${{ inputs.use-qemu }}
        uses: docker/setup-qemu-action@v3

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Create HF token file (optional)
        env:
          HF_ACCESS_TOKEN: ${{ secrets.HF_ACCESS_TOKEN }}
        run: |
          mkdir -p ./scripts/private_local
          if [ -n "${HF_ACCESS_TOKEN}" ]; then
            printf '%s' "${HF_ACCESS_TOKEN}" > ./scripts/private_local/hf_token.txt
          fi

      - name: Build Docker image (load locally)
        run: |
          set -euo pipefail

          TAGS="${{ inputs.tags }}"
          TAG_ARGS=""

          sanitize_image_ref() {
            local ref="$1"
            local after_slash="${ref##*/}"

            # Only sanitize the *tag* portion (after the last ':', and only if
            # that ':' occurs after the last '/'). This avoids breaking
            # registries with ports like "registry:5000/repo:tag".
            if [[ "$after_slash" == *:* ]]; then
              local name="${ref%:*}"
              local tag="${ref##*:}"

              # Docker tags must match [A-Za-z0-9_][A-Za-z0-9_.-]{0,127}
              # Replace common offenders (like '/' from refs/heads/...) with '-'.
              local safe_tag="${tag//\//-}"
              safe_tag="${safe_tag// /-}"
              safe_tag="${safe_tag//:/-}"
              safe_tag="${safe_tag//[^A-Za-z0-9_.-]/-}"
              safe_tag="${safe_tag#[-.]}" # strip leading '-' or '.'
              safe_tag="${safe_tag:0:128}"

              if [[ -z "$safe_tag" ]]; then
                safe_tag="sha-${GITHUB_SHA}"
                safe_tag="${safe_tag:0:128}"
              fi

              printf '%s:%s' "$name" "$safe_tag"
              return 0
            fi

            printf '%s' "$ref"
          }

          IFS=',' read -ra TAG_ARR <<< "$TAGS"
          for t in "${TAG_ARR[@]}"; do
            t="$(echo "$t" | xargs)"
            if [ -n "$t" ]; then
              t="$(sanitize_image_ref "$t")"
              TAG_ARGS="$TAG_ARGS -t $t"
            fi
          done

          SECRET_ARG=""
          if [ -f ./scripts/private_local/hf_token.txt ] && [ -s ./scripts/private_local/hf_token.txt ]; then
            SECRET_ARG="--secret id=hf_token,src=./scripts/private_local/hf_token.txt"
          fi

          DOWNLOAD_LLAMA="True"
          if [ "${{ inputs.download-llama-tokenizer }}" != "true" ]; then
            DOWNLOAD_LLAMA="False"
          fi

          docker buildx build \
            --platform "${{ inputs.platform }}" \
            --load \
            --target "${{ inputs.target }}" \
            --build-arg GIT_COMMIT=${GITHUB_SHA} \
            --build-arg BASE_IMG="${{ inputs.base-image }}" \
            --build-arg BASE_IMG_TAG="${{ inputs.base-image-tag }}" \
            --build-arg DOWNLOAD_LLAMA_TOKENIZER=$DOWNLOAD_LLAMA \
            $SECRET_ARG \
            $TAG_ARGS \
            .

      - name: Run tests inside Docker container
        run: |
          set -euo pipefail

          TAGS="${{ inputs.tags }}"
          PLATFORM="${{ inputs.platform }}"
          MARKERS="${{ inputs.pytest-markers }}"
          TEST_PATHS="tests/service_tests client/client_tests api/api_tests"

          sanitize_image_ref() {
            local ref="$1"
            local after_slash="${ref##*/}"
            if [[ "$after_slash" == *:* ]]; then
              local name="${ref%:*}"
              local tag="${ref##*:}"
              local safe_tag="${tag//\//-}"
              safe_tag="${safe_tag// /-}"
              safe_tag="${safe_tag//:/-}"
              safe_tag="${safe_tag//[^A-Za-z0-9_.-]/-}"
              safe_tag="${safe_tag#[-.]}"
              safe_tag="${safe_tag:0:128}"
              if [[ -z "$safe_tag" ]]; then
                safe_tag="sha-${GITHUB_SHA}"
                safe_tag="${safe_tag:0:128}"
              fi
              printf '%s:%s' "$name" "$safe_tag"
              return 0
            fi
            printf '%s' "$ref"
          }

          IFS=',' read -ra TAG_ARR <<< "$TAGS"
          IMAGE=""
          for t in "${TAG_ARR[@]}"; do
            t="$(echo "$t" | xargs)"
            if [ -n "$t" ]; then
              IMAGE="$(sanitize_image_ref "$t")"
              break
            fi
          done
          if [ -z "$IMAGE" ]; then
            echo "Error: no image tag found to run tests (inputs.tags was empty)"
            exit 1
          fi

          if [ "${{ inputs.test-selection }}" != "full" ] && [ "${{ inputs.test-selection }}" != "random" ]; then
            echo "Error: test-selection must be 'full' or 'random'"
            exit 1
          fi

          if [ "${{ inputs.coverage }}" = "true" ]; then
            COV_ARGS="--cov nv_ingest --cov nv_ingest_client --cov nv_ingest_api --cov-report term --cov-report xml:/tmp/coverage.xml"
          else
            COV_ARGS=""
          fi

          if [ "${{ inputs.test-selection }}" = "full" ]; then
            CMD="python -m pytest -rs -m \"$MARKERS\" $COV_ARGS $TEST_PATHS"
          else
            N="${{ inputs.random-count }}"
            CMD="set -euo pipefail; \
              python -m pytest --collect-only -q $TEST_PATHS | grep '::' | shuf -n \"$N\" > /tmp/selected-tests.txt; \
              python -m pytest -rs -m \"$MARKERS\" $COV_ARGS \$(cat /tmp/selected-tests.txt)"
          fi

          if [ "${{ inputs.coverage }}" = "true" ]; then
            CID="$(docker create --platform "$PLATFORM" "$IMAGE" bash -lc "$CMD")"
            docker start -a "$CID"
            docker cp "$CID":/tmp/coverage.xml coverage.xml || true
            docker rm -f "$CID"
          else
            docker run --rm --platform "$PLATFORM" "$IMAGE" bash -lc "$CMD"
          fi

      - name: Upload coverage report
        if: ${{ inputs.coverage }}
        uses: actions/upload-artifact@v4
        with:
          name: coverage-xml
          path: coverage.xml
          if-no-files-found: warn

      - name: Cleanup HF token file
        if: always()
        run: rm -f ./scripts/private_local/hf_token.txt
